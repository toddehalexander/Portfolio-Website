<!DOCTYPE html>
<html lang="en">
    <head>
<!-- FAVICONS -->
<link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
<link rel="icon" type="image/x-icon" href="/assets/favicon.ico">
<link rel="manifest" href="/site.webmanifest">
<link rel="stylesheet" href="/css/styles.css">

<!-- FAVICONS -->
<meta name="description" content="Welcome to the portfolio of Toddeh Alexander. Explore my work and skills in web development.">
<meta name="keywords" content="Toddeh Alexander, Toddeh, Portfolio, Web Development, Front-end, Back-end, HTML, CSS, JavaScript">
<meta name="author" content="Toddeh Alexander">
<title>Rat23F Compiler - Toddeh Alexander</title>  
</head>

<body>
    
<a class="muted small" href="../">← toddeh alexander</a>
<h1>Rat23F Compiler •
    <span style="font-size: 20px; font-weight:normal;">
      <img class="inline-img" width="50px" src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg" alt="python img">
      <img class="inline-img" width="50px" src="https://camo.githubusercontent.com/da7acacadecf91d6dc02efcd2be086bb6d78ddff19a1b7a0ab2755a6fda8b1e9/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f64657669636f6e732f64657669636f6e2f69636f6e732f68746d6c352f68746d6c352d6f726967696e616c2e737667" alt="html img">
    </span>
  </h1>




<p class="muted small">Published on December 8, 2023</p>
<a class="port-link" href="https://github.com/toddehalexander/Rat23FCompiler" target="_blank"><strong>GitHub</strong></a>

<hr />

<h2>Problem Statement</h2>
<p>
    The task at hand encompasses two primary objectives: symbol table handling and assembly code generation for a simplified version of Rat23F. The modified Rat23F excludes &lt;Function Definitions&gt; and prohibits the use of "real" types.
</p>

<h3>Symbol Table Handling</h3>
<p>
    It involves organizing every declared identifier into a symbol table and developing procedures for access.
</p>
<ol>
    <li>a) Each entry in the symbol table should contain the lexeme and a "memory address" where the identifier is stored. The process involves initializing a global integer variable ("Memory_address") to 7000 and incrementing it by one for each new identifier added to the table.</li>
    <li>b) Essential procedures entail checking for existing identifiers, inserting new ones into the table, and printing all identifiers present. Additionally, the parser must flag errors for undeclared or duplicate identifiers and ensure type compatibility for operations.</li>
</ol>

<h3>Assembly Code Generation</h3>
<p>
    The parser needs modification to comply with the constraints of simplified Rat23F, incorporating code generation to produce assembly instructions.
</p>
<ol>
    <li>These instructions are to be stored in an array, capable of holding a minimum of 1000 instructions, indexed starting from 1.</li>
    <li>The resulting array should facilitate label-based jumping within the code.</li>
    <li>Furthermore, the compiler output should include a comprehensive list of all identifiers used.</li>
</ol>

<h2>How to use your program</h2>
<p>
    Prepare a text file containing the source code written in the simplified Rat23F language. Ensure that the code adheres to the specified guidelines, including the absence of &lt;Function Definitions&gt;, adherence to boolean arithmetic limitations, and strict type matching for arithmetic operations.
</p>

<h3>Usage</h3>
<p>
    You are able to run the exe file located inside the zip file, which requires the txt file to be located in the same directory as the exe. The exe will prompt the user to submit the name of the text file, and after doing so, the txt file is parsed, and the output is provided in the same directory as the exe. After giving the executable the text file’s name, it will create an output.txt which will have the compiled code with the appropriate symbol table and assembly code.
</p>

<h2>Design of your program</h2>
<p>
    The program's main components include symbol table handling and assembly code generation for the simplified Rat23F language. In the symbol table handling part, every declared identifier is managed through procedures that place entries in a symbol table. Each entry in the table stores the lexeme and a "memory address" for the identifier. Procedures check for existing identifiers, insert new ones, and print all entries. The parser ensures error messages for undeclared or redeclared identifiers and checks type matches.
</p>
<p>
    For the parser, it is modified to produce assembly code given simplified Rat23F, using new code to produce instructions stored in an array holding at least 1000 assembly instructions. The compiler also generates a listing of all identifiers used in the program, with array indices serving as a label to jump to.
</p>
<p>
    It prompts the user for an input file name, allowing an optional output file name (defaulting to 'output.txt' if not provided). It reads the input file, tokenizes it using the Lexer class, parses the tokens for syntax analysis using an external parser function, generates a symbol table based on the syntax analysis using the SymbolTable class, and creates assembly code using the Assembly class.
</p>
<p>
    After processing, it prints the assembly code to the console and writes both the symbol table and assembly code to an output file. Error handling is implemented using a try-except block to catch exceptions and display relevant error messages. The program's flow is structured within the main() function, initiating the entire process and handling user inputs and outputs accordingly. To improve, clearer comments explaining each step and enhanced error messages could make it more user-friendly. Additionally, optimizations in code structure and potential enhancements in error handling could be considered for better reliability.
</p>

<h3>Syntax Analyzer</h3>
<p>
    Regarding the <code>syntax_analyzer.py</code> file, it contains functionalities related to the syntax analysis phase. Here, functions or a class (like a parser) handle parsing the tokens generated by the lexer. This phase verifies whether the token arrangement follows the syntax rules defined by the programming language's grammar. It structures the tokens into a coherent format, such as a syntax tree or intermediate representation, ensuring adherence to the language's syntax rules.
</p>
<p>
    Both files, <code>lexer.py</code> and <code>syntax_analyzer.py</code>, are integral to converting source code into a machine-understandable format. The lexer dissects code into tokens, while the syntax analyzer validates the code's structure according to the language's grammar. These components provide organized data for subsequent stages, facilitating further analysis and eventual code generation or interpretation.
</p>
<footer>
    <p class="muted small">
      © 2023 | <a class="muted">Toddeh Alexander</a>
    </p>
  </footer>
</body>
</html>